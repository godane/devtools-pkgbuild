#!/bin/bash
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# Most recent commit: Move build and package logs...

FORCE='n'
RUN=''
MAKEPKG_ARGS='-sr'
REPACK=''
COPY='copy'
WORKDIR=$PWD

update_first='0'
clean_first='1'
install_pkg=''
add_to_db=0
usetesting=0
makearch='x86_64'
chrootdir=''

APPNAME=$(basename "${0}")
MUSER=$(echo $HOME | sed -e 's|/home/||')

usage ()
{
	echo "usage ${APPNAME} [options] -r <chrootdir> [--] [makepkg args]"
	echo ' Run this script in a PKGBUILD dir to build a package inside a'
	echo ' clean chroot. All unrecognized arguments passed to this script'
	echo ' will be passed to makepkg.'
	echo ''
	echo ' The chroot dir consists of the following directories:'
	echo ' <chrootdir>/{root, copy} but only 'root' is required'
	echo ' by default. The working copy will be created as needed'
	echo ''
	echo 'The chroot 'root' directory must be created via the following'
	echo 'command:'
	echo '    mkarchroot <chrootdir>/root base base-devel sudo'
	echo ''
	echo "Default makepkg args: $MAKEPKG_ARGS"
	echo ''
	echo 'Flags:'
	echo '-h         This help'
	echo '-u         Update the working copy of the chroot before building'
	echo '           This is useful for rebuilds without dirtying the pristine'
	echo '           chroot'
	echo '-d         Add the package to a local db at /repo after building'
	echo '-t         Enable the testing repo'
	echo '-a         Specify the architecture to build for'
	echo '-I <pkg>   Install a package into the working copy of the chroot'
	echo '-l <layer> The directory to use as the working copy of the chroot'
	echo '           Useful for maintain multiple copies. Default: copy'
	exit 1
}

while getopts 'hcudta:I:l:' arg; do
	case "${arg}" in
		h) usage ;;
		c) clean_first=1 ;;
		u) update_first=1 ;;
		d) add_to_db=1 ;;
		t) usetesting=1 ;;
		a) makearch="$OPTARG" ;;
		I) install_pkg="$OPTARG" ;;
		l) COPY="$OPTARG" ;;
		*) MAKEPKG_ARGS="$MAKEPKG_ARGS -$arg $OPTARG" ;;
	esac
done

# Pass all arguments after -- right to makepkg
MAKEPKG_ARGS="$MAKEPKG_ARGS ${*:$OPTIND}"

# See if -R was passed to makepkg
for arg in ${*:$OPTIND}; do
	if [ "$arg" = '-R' ]; then
		REPACK=1
		break;
	fi
done

if [ "$EUID" != '0' ]; then
	echo 'This script must be run as root.'
	exit 1
fi

if [ ! -f PKGBUILD ]; then
	echo 'This must be run in a directory containing a PKGBUILD.'
	exit 1
fi
source PKGBUILD

if [ "$makearch" != 'i686' ] && [ "$makearch" != 'x86_64' ]; then
	echo "$makearch is not a valid architecture, defaulting to x86_64."
fi

if [ -f '/var/lock/makechroot.1' ] && [ ! -f '/var/lock/makechroot.2' ]; then
	# Use second queue spot
	QUEUELOCK="/var/lock/makechroot.2"
	echo "Locked by $MUSER at $(date +'%H%M') (GMT+6) on $(date +'%D')" >> $QUEUELOCK
elif [ -f '/var/lock/makechroot.2' ] && [ ! -f '/var/lock/makechroot.1' ]; then
	# Use first queue spot
	QUEUELOCK="/var/lock/makechroot.1"
	echo "Locked by $MUSER at $(date +'%H%M') (GMT+6) on $(date +'%D')" >> $QUEUELOCK
elif [ -f '/var/lock/makechroot.1' ] && [ -f '/var/lock/makechroot.2' ]; then
	echo 'The chroot queue is currently full, please try again in a few minutes.'
	exit 1
else
	# Use first queue spot
	QUEUELOCK="/var/lock/makechroot.1"
	echo "Locked by $MUSER at $(date +'%H%M') (GMT+6) on $(date +'%D')" >> $QUEUELOCK
fi

if [ "$usetesting" != "0" ]; then
	makearch="${makearch}-testing"
fi

if [ -f "/var/lock/make${makearch}.1" ]; then
	# Use second chroot
	CHROOTLOCK="/var/lock/make${makearch}.2"
	echo "Locked by $MUSER at $(date +'%H%M') (GMT+6) on $(date +'%D')" >> $CHROOTLOCK
	chrootdir="/chroot/${makearch}/2"
else
	# Use first chroot
	CHROOTLOCK="/var/lock/make${makearch}.1"
	echo "Locked by $MUSER at $(date +'%H%M') (GMT+6) on $(date +'%D')" >> $CHROOTLOCK
	chrootdir="/chroot/${makearch}/1"
fi

if [ ! -d "$chrootdir" ]; then
	echo "No chroot dir defined, or invalid path '$chrootdir'"
	rm -f $QUEUELOCK $CHROOTLOCK
	exit 1
fi

if [ ! -d "$chrootdir/root" ]; then
	echo 'Missing chroot dir root directory.'
	echo "Try using: mkarchroot $chrootdir/root base base-devel sudo"
	rm -f $QUEUELOCK $CHROOTLOCK
	usage
fi

#Get rid of trailing / in chrootdir
[ "$chrootdir" != "/" ] && chrootdir=$(echo $chrootdir | sed 's#/$##')
copydir="$chrootdir/$COPY"

umask 0022
if [ ! -d "$copydir" -o "$clean_first" -eq "1" ]; then
	echo -n 'creating clean working copy...'
	mkdir -p "$copydir"
	rsync -a --delete -q -W -x "$chrootdir/root/" "$copydir"
	echo 'done'
fi

if [ -n "$install_pkg" ]; then
	pkgname="$(basename "$install_pkg")"
	cp "$install_pkg" "$copydir/$pkgname"
	mkarchroot -r "pacman -U /$pkgname" "$copydir"
	ret=$?
	rm "$copydir/$pkgname"
	#exit early, we've done all we need to
	exit $ret
fi

if [ $update_first -eq 1 ]; then
	mkarchroot -r 'pacman -Syu --noconfirm' "$copydir"
fi

[ -d "$copydir/build" ] || mkdir "$copydir/build"

if [ "$REPACK" != "1" ]; then
	#Remove anything in there UNLESS -R (repack) was passed to makepkg
	rm -rf "$copydir/build/"*
fi

# Get SRC/PKGDEST from makepkg.conf
SRCDEST=$(grep '^SRCDEST=' /etc/makepkg.conf | cut -d= -f2)
PKGDEST=$(grep '^PKGDEST=' /etc/makepkg.conf | cut -d= -f2)

[ -d "$copydir/pkgdest" ] || mkdir "$copydir/pkgdest"
if ! grep 'PKGDEST=/pkgdest' "$copydir/etc/makepkg.conf" >/dev/null 2>&1; then
	echo 'PKGDEST=/pkgdest' >> "$copydir/etc/makepkg.conf"
fi

[ -d "$copydir/srcdest" ] || mkdir "$copydir/srcdest"
if ! grep 'SRCDEST=/srcdest' "$copydir/etc/makepkg.conf" >/dev/null 2>&1; then
	echo 'SRCDEST=/srcdest' >> "$copydir/etc/makepkg.conf"
fi

if [ -f "$HOME/.packager" ]; then
	sed -i "s|PKGBUILD.com Build Server|$(head -n1 $HOME/.packager | sed s/\"//g)|" $copydir/etc/makepkg.conf
fi

# Set target CARCH as it might be used withing the PKGBUILD to select correct sources
CARCH=$(eval $(grep '^CARCH=' "$copydir/etc/makepkg.conf"))
# Copy PKGBUILD and sources
source PKGBUILD
cp PKGBUILD "$copydir/build/"
for f in ${source[@]}; do
	basef=$(echo $f | sed 's|::.*||' | sed 's|^.*://.*/||g')
	if [ -f "$basef" ]; then
		cp "$basef" "$copydir/srcdest/"
	elif [ -f "$SRCDEST/$basef" ]; then
		cp "$SRCDEST/$basef" "$copydir/srcdest/"
	fi
done

install_files=$(grep 'install=' PKGBUILD)
for pkg in ${pkgname[@]}; do
	install_files+=' '
	install_files+=$(echo $install_files |sed "s/\$pkgname/$pkg/"|sed "s/\${pkgname}/$pkg/")
	install_files=$(eval echo $install_files |tr '[:blank:]' '\n'|sort |uniq)
done

for f in $install_files;do
	install="${f#"install="}"
	if [ "$install" != "" -a -f "$install" ]; then
		cp "$install" "$copydir/build/"
	fi
done

if [ -f 'ChangeLog' ]; then
	cp ChangeLog "$copydir/build/"
fi

chown -R nobody "$copydir/build"
chown -R nobody "$copydir/srcdest"
chown -R nobody "$copydir/pkgdest"

if ! grep "^nobody" "$copydir/etc/sudoers" >/dev/null 2>&1; then
	touch "$copydir/etc/sudoers"
	echo 'nobody	ALL=(ALL) NOPASSWD: ALL' >> "$copydir/etc/sudoers"
	chmod 440 "$copydir/etc/sudoers"
fi

#This is a little gross, but this way the script is recreated every time in the
#working copy
(cat <<EOF
#!/bin/bash
export LANG=$LOCALE
cd /build
export HOME=/build
sudo -u nobody makepkg $MAKEPKG_ARGS || touch BUILD_FAILED
[ -f BUILD_FAILED ] && rm -f $QUEUELOCK $CHROOTLOCK && exit 1
which namcap &>/dev/null && namcap /build/PKGBUILD /pkgdest/*.pkg.tar.* > /pkgdest/namcap.log
exit 0
EOF
) > "$copydir/chrootbuild"
chmod +x "$copydir/chrootbuild"

if mkarchroot -r "/chrootbuild" "$copydir"; then
	for pkgfile in "${copydir}"/pkgdest/*.pkg.tar.*; do
		[ -e "$pkgfile" ] || continue
		_pkgname=$(basename "$pkgfile")
		if [ "$add_to_db" -eq "1" ]; then
			[ -d "${copydir}/repo" ] || mkdir -p "${copydir}/repo"
			pushd "${copydir}/repo" >/dev/null
			cp "$pkgfile" .
			repo-add repo.db.tar.gz "$_pkgname"
			popd >/dev/null
		fi

		if [ -d "$PKGDEST" ]; then
			mv "$pkgfile" "${PKGDEST}"
		else
			mv "$pkgfile" "${WORKDIR}"
		fi
	 done

	for l in "${copydir}"/build/*-{build,package}.log; do
		[ -f "$l" ] && mv "$l" "${WORKDIR}"
	done
	chown -R "$MUSER:dev" "${WORKDIR}"
else
	#just in case. We returned 1, make sure we fail
	touch "${copydir}/build/BUILD_FAILED"
fi

for f in "${copydir}"/srcdest/*; do
	[ -e "$f" ] || continue
	if [ -d "$SRCDEST" ]; then
		mv "$f" "${SRCDEST}"
	else
		mv "$f" "${WORKDIR}"
	fi
done

rm -f $QUEUELOCK $CHROOTLOCK

if [ -e "${copydir}/build/BUILD_FAILED" ]; then
	echo "Build failed, check ${copydir}/build"
	rm "${copydir}/build/BUILD_FAILED"
	exit 1
else
	rm -rf "${copydir}"/build/*
fi	

# vim: set noexpandtab tabstop=8 shiftwidth=8 wrap:textwidth=132 autoindent
# kate: indent-mode normal; indent-width 8; tab-indents on; tab-width 8; word-wrap on; word-wrap-column 132
