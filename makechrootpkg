#!/bin/bash
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# Most recent commit: Move build and package logs...

FORCE="n"
RUN=""
MAKEPKG_ARGS="-sr"
REPACK=""
LAYER="rw"
WORKDIR=$PWD

update_first="0"
clean_first="1"
install_pkg=""
add_to_db=0
usetesting=0
makearch="x86_64"
chrootdir=""

APPNAME=$(basename "${0}")
MUSER=$(echo $HOME | sed -e 's|/home/||')

usage ()
{
    echo "usage ${APPNAME} [options] -r <chrootdir> [--] [makepkg args]"
    echo " Run this script in a PKGBUILD dir to build a package inside a"
    echo " clean chroot. All unrecognized arguments passed to this script"
    echo " will be passed to makepkg."
    echo ""
    echo " The chroot dir consists of the following directories:"
    echo " <chrootdir>/{root, rw, union} but only 'root' is required"
    echo " by default. The rest will be created as needed"
    echo ""
    echo "The chroot 'root' directory must be created via the following"
    echo "command:"
    echo "    mkarchroot <chrootdir>/root base base-devel sudo"
    echo ""
    echo "Default makepkg args: $MAKEPKG_ARGS"
    echo ""
    echo "Flags:"
    echo "-h         This help"
    echo "-u         Update the rw layer of the chroot before building"
    echo "           This is useful for rebuilds without dirtying the pristine"
    echo "           chroot"
    echo "-d         Add the package to a local db at /repo after building"
    echo "-t         Enable the testing repo"
    echo "-a         Specify the architecture to build for"
    echo "-I <pkg>   Install a package into the rw layer of the chroot"
    echo "-l <layer> The directory to use as the rw layer of the union"
    echo "           Useful for maintain multiple layers. Default: rw"
    exit 1
}

while getopts 'hcudta:I:l:' arg; do
    case "${arg}" in
        h) usage ;;
	c) clean_first=1 ;;
        u) update_first=1 ;;
        d) add_to_db=1 ;;
	t) usetesting=1 ;;
	a) makearch="$OPTARG" ;;
        I) install_pkg="$OPTARG" ;;
        l) LAYER="$OPTARG" ;;
        *) MAKEPKG_ARGS="$MAKEPKG_ARGS -$arg $OPTARG" ;;
    esac
done

#Get rid of trailing / in chrootdir
[ "$chrootdir" != "/" ] && chrootdir=$(echo $chrootdir | sed 's#/$##')

# Pass all arguments after -- right to makepkg
MAKEPKG_ARGS="$MAKEPKG_ARGS ${*:$OPTIND}"

# See if -R was passed to makepkg
for arg in ${*:$OPTIND}; do
    if [ "$arg" = "-R" ]; then
        REPACK=1
        break;
    fi
done

if [ "$EUID" != "0" ]; then
    echo "This script must be run as root."
    exit 1
fi

if [ ! -f PKGBUILD ]; then
    echo "This must be run in a directory containing a PKGBUILD."
    exit 1
fi
source PKGBUILD

if [ "$makearch" != "i686" ] && [ "$makearch" != "x86_64" ]; then
    echo "$makearch is not a valid architecture, defaulting to x86_64."
fi

if [ -f "/var/lock/makechroot.1" ] && [ ! -f "/var/lock/makechroot.2" ]; then
    # Use second queue spot
    QUEUELOCK="/var/lock/makechroot.2"
    echo "Locked by $MUSER at $(date +'%H%M') (GMT+6) on $(date +'%D')" >> $QUEUELOCK
elif [ -f "/var/lock/makechroot.2" ] && [ ! -f "/var/lock/makechroot.1" ]; then
    # Use first queue spot
    QUEUELOCK="/var/lock/makechroot.1"
    echo "Locked by $MUSER at $(date +'%H%M') (GMT+6) on $(date +'%D')" >> $QUEUELOCK
elif [ -f "/var/lock/makechroot.1" ] && [ -f "/var/lock/makechroot.2" ]; then
    echo "The chroot queue is currently full, please try again in a few minutes."
    exit 1
else
    # Use first queue spot
    QUEUELOCK="/var/lock/makechroot.1"
    echo "Locked by $MUSER at $(date +'%H%M') (GMT+6) on $(date +'%D')" >> $QUEUELOCK
fi

if [ "$usetesting" != "0" ]; then
    makearch="${makearch}-testing"
fi

if [ -f "/var/lock/make${makearch}.1" ]; then
    # Use second chroot
    CHROOTLOCK="/var/lock/make${makearch}.2"
    echo "Locked by $MUSER at $(date +'%H%M') (GMT+6) on $(date +'%D')" >> $CHROOTLOCK
    chrootdir="/chroot/${makearch}/2"
else
    # Use first chroot
    CHROOTLOCK="/var/lock/make${makearch}.1"
    echo "Locked by $MUSER at $(date +'%H%M') (GMT+6) on $(date +'%D')" >> $CHROOTLOCK
    chrootdir="/chroot/${makearch}/1"
fi

if [ ! -d "$chrootdir" ]; then
    echo "No chroot dir defined, or invalid path '$chrootdir'"
    rm -f $QUEUELOCK $CHROOTLOCK
    if [ ! -f /root/.nobroadcast ]; then
        wall "A spot has opened up in the queue. Happy building! "
    fi
    exit 1
fi

if [ ! -d "$chrootdir/root" ]; then
    echo "Missing chroot dir root directory."
    echo "Try using: mkarchroot $chrootdir/root base base-devel sudo"
    rm -f $QUEUELOCK $CHROOTLOCK
    if [ ! -f /root/.nobroadcast ]; then
        wall "A spot has opened up in the queue. Happy building! "
    fi
    usage
fi

umask 000
[ -d "$chrootdir/$LAYER" -a "$clean_first" -eq "1" ] && rm -rf "$chrootdir/$LAYER/" 
[ -d "$chrootdir/$LAYER" ] || mkdir "$chrootdir/$LAYER"
[ -d "$chrootdir/union" ] || mkdir "$chrootdir/union"

cleanup ()
{
    echo "cleaning up unioned mounts"
    umount "$chrootdir/union"
}

uniondir="$chrootdir/union"
echo "building union chroot $chrootdir"
grep -Fq aufs /proc/filesystems
if [ $? -ne 0 ]; then
    modprobe -q aufs
    if [ $? -ne 0 ]; then
        echo "ERROR: No aufs available. Abandon ship!" 
        rm -f $QUEUELOCK $CHROOTLOCK
        if [ ! -f /root/.nobroadcast ]; then
            wall "A spot has opened up in the queue. Happy building! "
        fi
        exit 1
    fi
fi
mount -t aufs none -o "dirs=$chrootdir/$LAYER=rw:$chrootdir/root=ro" "$uniondir"
trap 'cleanup' 0 1 2 15

if [ -n "$install_pkg" ]; then
    pkgname="$(basename "$install_pkg")"
    echo "installing '$pkgname' in chroot"
    cp "$install_pkg" "$uniondir/$pkgname"
    mkarchroot -r "pacman -U /$pkgname" "$uniondir"
    ret=$?
    rm "$uniondir/$pkgname"
    #exit early, we've done all we need to
    exit $ret
fi

if [ $update_first -eq 1 ]; then
    echo "updating chroot"
    mkarchroot -r "pacman -Syu --noconfirm" "$uniondir"
fi

echo "moving build files to chroot"
[ -d "$uniondir/build" ] || mkdir "$uniondir/build"

if [ "$REPACK" != "1" ]; then
    #Remove anything in there UNLESS -R (repack) was passed to makepkg
    rm -rf "$uniondir/build/"*
fi

# Get SRC/PKGDEST from makepkg.conf
SRCDEST=$(grep '^SRCDEST=' /etc/makepkg.conf | cut -d= -f2)
PKGDEST=$(grep '^PKGDEST=' /etc/makepkg.conf | cut -d= -f2)

[ -d "$uniondir/pkgdest" ] || mkdir "$uniondir/pkgdest"
if ! grep "PKGDEST=/pkgdest" "$uniondir/etc/makepkg.conf" >/dev/null 2>&1; then
    echo "Setting PKGDEST in makepkg.conf"
    echo "PKGDEST=/pkgdest" >> "$uniondir/etc/makepkg.conf"
fi

[ -d "$uniondir/srcdest" ] || mkdir "$uniondir/srcdest"
if ! grep "SRCDEST=/srcdest" "$uniondir/etc/makepkg.conf" >/dev/null 2>&1; then
    echo "Setting SRCDEST in makepkg.conf"
    echo "SRCDEST=/srcdest" >> "$uniondir/etc/makepkg.conf"
fi

if [ -f "$HOME/.packager" ]; then
    echo "Setting PACKAGER in makepkg.conf"
    sed -i "s|PKGBUILD.com Build Server|$(head -n1 $HOME/.packager | sed s/\"//g)|" $uniondir/etc/makepkg.conf
fi

# Copy PKGBUILD and sources
source PKGBUILD
cp PKGBUILD "$uniondir/build/"
for f in ${source[@]}; do
    basef=$(echo $f | sed 's|::.*||' | sed 's|^.*://.*/||g')
    if [ -f "$basef" ]; then
        cp "$basef" "$uniondir/srcdest/"
    elif [ -f "$SRCDEST/$basef" ]; then
        cp "$SRCDEST/$basef" "$uniondir/srcdest/"
    fi
done

install_files=$(grep "install=" PKGBUILD)
for pkg in ${pkgname[@]}; do
    install_files+=' '
    install_files+=$(echo $install_files |sed "s/\$pkgname/$pkg/"|sed "s/\${pkgname}/$pkg/")
    install_files=$(eval echo $install_files |tr '[:blank:]' '\n'|sort |uniq)
done

for f in $install_files;do
    install="${f#"install="}"
    if [ "$install" != "" -a -f "$install" ]; then
        cp "$install" "$uniondir/build/"
    fi
done

if [ -f "ChangeLog" ]; then
    cp ChangeLog "$uniondir/build/"
fi

chown -R nobody "$uniondir/build"
chown -R nobody "$uniondir/srcdest"
chown -R nobody "$uniondir/pkgdest"

if ! grep "^nobody" "$uniondir/etc/sudoers" >/dev/null 2>&1; then
    echo "allowing 'nobody' sudo rights in the chroot"
    touch "$uniondir/etc/sudoers"
    echo "nobody	ALL=(ALL) NOPASSWD: ALL" >> "$uniondir/etc/sudoers"
    chmod 440 "$uniondir/etc/sudoers"
fi

#This is a little gross, but this way the script is recreated every time in the
#rw portion of the union
(cat <<EOF
#!/bin/bash
export LANG=$LOCALE
cd /build
export HOME=/build
sudo -u nobody makepkg $MAKEPKG_ARGS || touch BUILD_FAILED
[ -f BUILD_FAILED ] && rm -f $QUEUELOCK $CHROOTLOCK && exit 1
which namcap &>/dev/null && namcap /build/PKGBUILD /pkgdest/*${PKGEXT} > /pkgdest/namcap.log
exit 0
EOF
) > "$uniondir/chrootbuild"
chmod +x "$uniondir/chrootbuild"

if mkarchroot -r "/chrootbuild" "$uniondir"; then

    for pkgfile in "${chrootdir}"/union/pkgdest/*${PKGEXT}; do
        [ -e "$pkgfile" ] || continue
        _pkgname=$(basename "$pkgfile")
        if [ "$add_to_db" -eq "1" ]; then
                [ -d "${chrootdir}/union/repo" ] || mkdir -p "${chrootdir}/union/repo"
                pushd "${chrootdir}/union/repo" >/dev/null
                cp "$pkgfile" .
                repo-add repo.db.tar.gz "$_pkgname"
                popd >/dev/null
        fi

        if [ -d "$PKGDEST" ]; then
            echo "Moving completed ${_pkgname%${PKGEXT}} package file to ${PKGDEST}"
            mv "$pkgfile" "${PKGDEST}"
        else
            echo "Moving completed ${_pkgname%${PKGEXT}} package file to ${WORKDIR}"
            mv "$pkgfile" "${WORKDIR}"
        fi
    done

    for f in "${chrootdir}"/union/srcdest/*; do
        [ -e "$f" ] || continue
        if [ -d "$SRCDEST" ]; then
            echo "Moving downloaded source file $(basename $f) to ${SRCDEST}"
            mv "$f" "${SRCDEST}"
        else
            echo "Moving downloaded source file $(basename $f) to ${WORKDIR}"
            mv "$f" "${WORKDIR}"
        fi
    done

    for l in "${uniondir}"/build/*-{build,package}.log; do
        [ -f "$l" ] && mv "$l" "${WORKDIR}"
    done
else
    #just in case. We returned 1, make sure we fail
    touch "${chrootdir}/union/build/BUILD_FAILED"
fi

rm -f $QUEUELOCK $CHROOTLOCK

if [ -e "${chrootdir}/union/build/BUILD_FAILED" ]; then
    echo "Build failed, check $chrootdir/$LAYER/build"
    rm "${chrootdir}/union/build/BUILD_FAILED"
else
    rm -rf "${chrootdir}"/union/build/*
    echo "Build complete"
fi	
if [ ! -f /root/.nobroadcast ]; then
    wall "A spot has opened up in the queue. Happy building! "
fi

# vim:ft=sh:ts=4:sw=4:et:
